<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QTL analysis · flxQTL.jl</title><link rel="canonical" href="https://hkim89.github.io/flxQTL.jl/stable/guide/analysis/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">flxQTL.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../tutorial/">Guide</a></li><li class="is-active"><a class="tocitem" href>QTL analysis</a><ul class="internal"><li><a class="tocitem" href="#Input-data-file-format"><span>Input data file format</span></a></li><li><a class="tocitem" href="#Reading-the-data-files-and-processing-arrays"><span>Reading the data files and processing arrays</span></a></li><li><a class="tocitem" href="#Computing-a-genetic-(or-climatic)-relatedness-matrix"><span>Computing a genetic (or climatic) relatedness matrix</span></a></li><li><a class="tocitem" href="#D-genome-scan"><span>1D genome scan</span></a></li><li><a class="tocitem" href="#Generating-plots"><span>Generating plots</span></a></li><li><a class="tocitem" href="#Performing-a-permutation-test"><span>Performing a permutation test</span></a></li></ul></li><li><a class="tocitem" href="../../functions/">Types and Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QTL analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QTL analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hkim89/flxQTL.jl/blob/master/docs/src/guide/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QTL-analysis"><a class="docs-heading-anchor" href="#QTL-analysis">QTL analysis</a><a id="QTL-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#QTL-analysis" title="Permalink"></a></h1><p>This section describes a step-by-step guide for QTL analysis.</p><h2 id="Input-data-file-format"><a class="docs-heading-anchor" href="#Input-data-file-format">Input data file format</a><a id="Input-data-file-format-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data-file-format" title="Permalink"></a></h2><p>The package <code>flxQTL</code> does not require any particular data format.  Any file readable in Julia is fine, but the input should contain traits (or phenotypes), genotype (probability), marker information on marker names, chromosomes, and marker positions, and optionally climatic information.  All inputs are types of  Arrays in Julia and should have no missing values, i.e. imputation is required if missing values exist.</p><h2 id="Reading-the-data-files-and-processing-arrays"><a class="docs-heading-anchor" href="#Reading-the-data-files-and-processing-arrays">Reading the data files and processing arrays</a><a id="Reading-the-data-files-and-processing-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-the-data-files-and-processing-arrays" title="Permalink"></a></h2><p>Use any Julia package able to read data files (<code>.txt</code>, <code>.csv</code>, etc.).  Julia&#39;s built-in module <code>DelimitedFiles</code> supports read, and write files.  Let&#39;s try using an example dataset in <code>flxQTL</code>. It is plant data: Arabidopsis thaliana in the <code>data</code> folder.  Detailed description on the data can be  referred to <code>README</code> in the folder.</p><pre><code class="language-julia">julia&gt; using DelimitedFiles

julia&gt; pheno = readdlm(&quot;data/Arabidopsis_fitness.csv&quot;;skipstart=1); # skip to read the first row (column names) to obtain a matrix only

julia&gt; geno = readdlm(&quot;data/Arabidopsis_genotypes.csv&quot;;skipstart=1); 

julia&gt; markerinfo = readdlm(&quot;data/Arabidopsis_markerinfo_1d.csv&quot;,&#39;,&#39;;skipstart=1);
</code></pre><p>For efficient computation, the normalization of matrices is necessary.  The phenotype matrix labelled as <code>pheno</code> here composes of wide range of values  from 1.774 to 34.133, so that it is better to narow the range of values in [0,1], [-1,1], or any narrower interval for easy computation.  Note that  the dimension of a phenotype matrix should be <code>the number of traits x the number of individuals</code>.</p><pre><code class="language-julia">julia&gt; Y=convert(Array{Float64,2},pheno&#39;); #convert from transposed one to a Float64 matrix
julia&gt; Ystd=(Y.-mean(Y,dims=2))./std(Y,dims=2); # sitewise normalization</code></pre><p>In the genotype data, <code>1</code>, <code>2</code> indicate Italian, Swedish parents, respectively. You can rescale the genotypes for efficiency. </p><pre><code class="language-julia">julia&gt; geno[geno.==1.0].=0.0;geno[geno.==2.0].=1.0; 
</code></pre><p>For genome scan, we need restructure the standardized genotype matrix combined with marker information.  Note that the genome scan in <code>flxQTL</code> is  implemented by CPU parallelization, so we need to add workers (or processes) before the genome scan.  Depending on the computer CPU, one can add as many  processes as possible. If your computer has 16 cores, then you can add 15 or little more.  The dimension of a genotype (probability) matrix should be  <code>the number of markers x the number of individuals</code>.</p><pre><code class="language-julia">julia&gt; addprocs(16) 
julia&gt; XX=flxQTL.Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno&#39;) # marker names, chromosomes, marker positions, genotypes
</code></pre><p>Optionally, one can generate a fixed (low-dimensional) trait covariate matrix (Z).  The first column indicates overall mean between the two regions, and  the second implies site difference: <code>-1</code> for Italy, and <code>1</code> for Sweden.</p><pre><code class="language-julia-repl">julia&gt; Z=hcat(ones(6),vcat(-ones(3),ones(3)))
6×2 Array{Float64,2}:
 1.0  -1.0
 1.0  -1.0
 1.0  -1.0
 1.0   1.0
 1.0   1.0
 1.0   1.0

julia&gt; m,q = size(Z) # check the dimension
(6, 2)</code></pre><h2 id="Computing-a-genetic-(or-climatic)-relatedness-matrix"><a class="docs-heading-anchor" href="#Computing-a-genetic-(or-climatic)-relatedness-matrix">Computing a genetic (or climatic) relatedness matrix</a><a id="Computing-a-genetic-(or-climatic)-relatedness-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-genetic-(or-climatic)-relatedness-matrix" title="Permalink"></a></h2><p>The submodule <code>GRM</code> contains functions for computing kinship matrices, <code>kinshipMan</code>, <code>kinship4way</code>, <code>kinshipGs</code>, <code>kinshipLin</code>, <code>kinshipCtr</code>, and computing  3D array of kinship matrices for LOCO (Leave One Chromosome Out) with (or without) a shrinkage method for nonpositive definiteness for the both,  <code>shrinkg</code>, <code>shrinkgLoco</code>, <code>kinshipLoco</code>.   Note that the shrinkage option is only for <code>kinshipMan</code>, <code>kinship4way</code>.</p><p>For the Arabidopsis genotype data, we will use a genetic relatedness matrix using manhattan distance measure, <code>kinshipMan</code> with a shrinkage and a  LOCO option.</p><pre><code class="language-julia">julia&gt; Kg = flxQTL.shrinkgLoco(flxQTL.kinshipMan,50,XX)</code></pre><p>For no LOCO option with shrinkage,</p><pre><code class="language-julia">julia&gt; K = flxQTL.shinkg(flxQTL.kinshipMan,50,XX.X)</code></pre><p>If you have climatic information on your trait data, you can compute the relatedness matrix using one of the above functions, but it is recommended using  <code>kinshipGs</code>,<code>kinshipLin</code>,<code>kinshipCtr</code> after normalization.  Since the climatic information is not available, we use an identity matrix.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; Kc = Matrix(1.0I,6,6) # 3 years x 2 sites
6×6 Array{Float64,2}:
 1.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0</code></pre><h2 id="D-genome-scan"><a class="docs-heading-anchor" href="#D-genome-scan">1D genome scan</a><a id="D-genome-scan-1"></a><a class="docs-heading-anchor-permalink" href="#D-genome-scan" title="Permalink"></a></h2><p>Once all input matrices are ready, we need to proceed the eigen-decomposition to two relatedness matrices.  For a non-identity climatic relatedness, and a kinship with LOCO, you can do eigen-decomposition simultaneously.  Since we use the identity climatic  relatedness, you can use <code>Matrix(1.0I,6,6)</code> for a matrix of eigenvectors and <code>ones(6)</code> for a vector of eigenvalues.</p><pre><code class="language-julia">julia&gt; Tg,Λg,Tc,λc = flxQTL.K2Eig(Kg,Kc,true); # the last argument: LOCO::Bool = false (default)</code></pre><p>For no LOCO option,</p><pre><code class="language-julia">julia&gt; T,λ = flxQTL.K2eig(K)</code></pre><p>Now start with 1D genome scan with (or without) LOCO including <code>Z</code> or not.   For the genome scan with LOCO including <code>Z</code>, </p><pre><code class="language-julia">julia&gt; LODs,B,est0 = flxQTL.geneScan(1,Tg,Tc,Λg,λc,Ytd,XX,Z,true); </code></pre><p>For the genome scan with LOCO excluding <code>Z</code>, i.e. an identity matrix, </p><pre><code class="language-julia">julia&gt; LODs,B,est0 = flxQTL.geneScan(1,Tg,Tc,Λg,λc,Ytd,XX,true); </code></pre><p>Note that the first argument in <code>geneScan</code> is <code>cross::Int64</code>, which indicates a type of genotype or genotype probability.  For instance, if you use a  genotype matrix whose entry is one of 0,1,2, type <code>1</code>. If you use genotype probability matrices, depending on the number of alleles or genotypes in a marker, one can type the corresponding number. i.e. <code>4-way cross: 4</code>, <code>HS DO mouse: 8 for alleles, 32 for genotypes</code>, etc.   </p><p>For no LOCO option,</p><pre><code class="language-julia">julia&gt; LODs,B,est0 = flxQTL.geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,Z);

julia&gt; LODs,B,est0 = flxQTL.geneScan(1,Tg,Tc,Λg,λc,Ystd,XX);</code></pre><p>The function <code>geneScan</code> has three arguments: <code>LOD scores (LODs)</code>, <code>effects matrix under H1 (B)</code>, and <code>parameter estimates under H0 (est0)</code>.   In particular, you can extract values from each matrix in <code>B</code> (3D array of matrices) to generate an effects plot.</p><h2 id="Generating-plots"><a class="docs-heading-anchor" href="#Generating-plots">Generating plots</a><a id="Generating-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-plots" title="Permalink"></a></h2><p>To produce a plot (or plots) for LOD scores or effects, you need first a struct of arrays, <code>layers</code> consisting of chromosomes, marker positions,  LOD scores (or effects).</p><pre><code class="language-julia">julia&gt; Arab_lod = flxQTL.layers(markerinfo[:,2],markerinfo[:,3],LODs)

julia&gt; plot1d(Arab_lod;title= &quot;LOD scores for Arabidopsis thaliana&quot;,ylabel=&quot;LOD&quot;)</code></pre><p>The function <code>plot1d</code> has more keyword argument options: <code>yint=[]</code> for a vector of y-intercept(s), <code>yint_color=[&quot;red&quot;]</code> for a vector of y-intercept  color(s), <code>Legend=[]</code> for multiple graphs, <code>loc=&quot;upper right&quot;</code> for the location of <code>Legend</code>.</p><h2 id="Performing-a-permutation-test"><a class="docs-heading-anchor" href="#Performing-a-permutation-test">Performing a permutation test</a><a id="Performing-a-permutation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-a-permutation-test" title="Permalink"></a></h2><p>Since the statistical inference for <code>flxQTL</code> relies on LOD scores and LOD scores, the function <code>permTest</code> finds thresholds for a type I error.  The first  argument is <code>nperm::Int64</code> to set the number of permutations for the test. For <code>Z = I</code>, type <code>Matrix(1.0I,6,6)</code> for the Arabidopsis thaliana data.</p><pre><code class="language-julia">julia&gt; maxLODs, H1par_perm, cutoff = flxQTL.permTest(1000,1,Kg,Kc,Ystd,XX,Z;pval=[0.05 0.01])</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Guide</a><a class="docs-footer-nextpage" href="../../functions/">Types and Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 25 November 2020 23:46">Wednesday 25 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
